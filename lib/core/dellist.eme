import "lib/core/list.eme"
import "lib/core/array.eme"
import "lib/core/option.eme"

dellist :: struct #export (T: type) {
  list: list(opt(T));
}

new :: fn #export #inline (dellist($T), length: int, capacity: int) -> dellist(T) {
  r: dellist(T);
  r.list = new(list(opt(T)), length, capacity);
  return r;
}

new :: fn #export #inline (dellist($T), length: int) -> dellist(T) {
  r: dellist(T);
  r.list = new(list(opt(T)), length);
  return r;
}

new :: fn #export #inline (dellist($T)) -> dellist(T) {
  r: dellist(T);
  r.list = new(list(opt(T)), length);
  return r;
}

subscript :: fn #export #inline #operator (x: dellist($T), i: int) -> ^opt(T) {
  return x.list^[i];
}

clean_up :: fn #export (x: ^dellist($T)) {
  i := 0;
  j := 0;
  while(i < x.list.array.length) {
    if((*x)[i].non_null) {
      (*x)[j] = (*x)[i];
      j = j + 1;
    }
    i = i + 1;
  }
  x.list.array.length = j;
}



iterator_make :: fn #inline #operator #export (a: dellist($T)) -> array_iter(opt(T)) {
  return iterator_make(a.list);
}
